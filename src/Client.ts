// This file was auto-generated by Fern from our API Definition.

import * as Extend from "./api/index";
import { BatchProcessorRunClient } from "./api/resources/batchProcessorRun/client/Client";
import { ClassifiersClient } from "./api/resources/classifiers/client/Client";
import { ClassifierVersionsClient } from "./api/resources/classifierVersions/client/Client";
import { ClassifyRunsClient } from "./api/resources/classifyRuns/client/Client";
import { EditRunsClient } from "./api/resources/editRuns/client/Client";
import { EvaluationSetItemsClient } from "./api/resources/evaluationSetItems/client/Client";
import { EvaluationSetRunsClient } from "./api/resources/evaluationSetRuns/client/Client";
import { EvaluationSetsClient } from "./api/resources/evaluationSets/client/Client";
import { ExtractorsClient } from "./api/resources/extractors/client/Client";
import { ExtractorVersionsClient } from "./api/resources/extractorVersions/client/Client";
import { ExtractRunsClient } from "./api/resources/extractRuns/client/Client";
import { FilesClient } from "./api/resources/files/client/Client";
import { ParseRunsClient } from "./api/resources/parseRuns/client/Client";
import { ProcessorClient } from "./api/resources/processor/client/Client";
import { ProcessorRunClient } from "./api/resources/processorRun/client/Client";
import { ProcessorVersionClient } from "./api/resources/processorVersion/client/Client";
import { SplitRunsClient } from "./api/resources/splitRuns/client/Client";
import { SplittersClient } from "./api/resources/splitters/client/Client";
import { SplitterVersionsClient } from "./api/resources/splitterVersions/client/Client";
import { WorkflowRunsClient } from "./api/resources/workflowRuns/client/Client";
import { WorkflowsClient } from "./api/resources/workflows/client/Client";
import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "./BaseClient";
import * as core from "./core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "./core/headers";
import * as environments from "./environments";
import { handleNonStatusCodeError } from "./errors/handleNonStatusCodeError";
import * as errors from "./errors/index";

export declare namespace ExtendClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ExtendClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ExtendClient.Options>;
    protected _files: FilesClient | undefined;
    protected _parseRuns: ParseRunsClient | undefined;
    protected _editRuns: EditRunsClient | undefined;
    protected _extractRuns: ExtractRunsClient | undefined;
    protected _extractors: ExtractorsClient | undefined;
    protected _extractorVersions: ExtractorVersionsClient | undefined;
    protected _classifyRuns: ClassifyRunsClient | undefined;
    protected _classifiers: ClassifiersClient | undefined;
    protected _classifierVersions: ClassifierVersionsClient | undefined;
    protected _splitRuns: SplitRunsClient | undefined;
    protected _splitters: SplittersClient | undefined;
    protected _splitterVersions: SplitterVersionsClient | undefined;
    protected _workflows: WorkflowsClient | undefined;
    protected _workflowRuns: WorkflowRunsClient | undefined;
    protected _processorRun: ProcessorRunClient | undefined;
    protected _processor: ProcessorClient | undefined;
    protected _processorVersion: ProcessorVersionClient | undefined;
    protected _batchProcessorRun: BatchProcessorRunClient | undefined;
    protected _evaluationSets: EvaluationSetsClient | undefined;
    protected _evaluationSetItems: EvaluationSetItemsClient | undefined;
    protected _evaluationSetRuns: EvaluationSetRunsClient | undefined;

    constructor(options: ExtendClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get files(): FilesClient {
        return (this._files ??= new FilesClient(this._options));
    }

    public get parseRuns(): ParseRunsClient {
        return (this._parseRuns ??= new ParseRunsClient(this._options));
    }

    public get editRuns(): EditRunsClient {
        return (this._editRuns ??= new EditRunsClient(this._options));
    }

    public get extractRuns(): ExtractRunsClient {
        return (this._extractRuns ??= new ExtractRunsClient(this._options));
    }

    public get extractors(): ExtractorsClient {
        return (this._extractors ??= new ExtractorsClient(this._options));
    }

    public get extractorVersions(): ExtractorVersionsClient {
        return (this._extractorVersions ??= new ExtractorVersionsClient(this._options));
    }

    public get classifyRuns(): ClassifyRunsClient {
        return (this._classifyRuns ??= new ClassifyRunsClient(this._options));
    }

    public get classifiers(): ClassifiersClient {
        return (this._classifiers ??= new ClassifiersClient(this._options));
    }

    public get classifierVersions(): ClassifierVersionsClient {
        return (this._classifierVersions ??= new ClassifierVersionsClient(this._options));
    }

    public get splitRuns(): SplitRunsClient {
        return (this._splitRuns ??= new SplitRunsClient(this._options));
    }

    public get splitters(): SplittersClient {
        return (this._splitters ??= new SplittersClient(this._options));
    }

    public get splitterVersions(): SplitterVersionsClient {
        return (this._splitterVersions ??= new SplitterVersionsClient(this._options));
    }

    public get workflows(): WorkflowsClient {
        return (this._workflows ??= new WorkflowsClient(this._options));
    }

    public get workflowRuns(): WorkflowRunsClient {
        return (this._workflowRuns ??= new WorkflowRunsClient(this._options));
    }

    public get processorRun(): ProcessorRunClient {
        return (this._processorRun ??= new ProcessorRunClient(this._options));
    }

    public get processor(): ProcessorClient {
        return (this._processor ??= new ProcessorClient(this._options));
    }

    public get processorVersion(): ProcessorVersionClient {
        return (this._processorVersion ??= new ProcessorVersionClient(this._options));
    }

    public get batchProcessorRun(): BatchProcessorRunClient {
        return (this._batchProcessorRun ??= new BatchProcessorRunClient(this._options));
    }

    public get evaluationSets(): EvaluationSetsClient {
        return (this._evaluationSets ??= new EvaluationSetsClient(this._options));
    }

    public get evaluationSetItems(): EvaluationSetItemsClient {
        return (this._evaluationSetItems ??= new EvaluationSetItemsClient(this._options));
    }

    public get evaluationSetRuns(): EvaluationSetRunsClient {
        return (this._evaluationSetRuns ??= new EvaluationSetRunsClient(this._options));
    }

    /**
     * Parse a file synchronously, waiting for the result before returning. This endpoint has a **5-minute timeout** — if processing takes longer, the request will fail.
     *
     * **Note:** This endpoint is intended for onboarding and testing only. For production workloads, use `POST /parse_runs` with [polling or webhooks](https://docs.extend.ai/2026-02-09/developers/async-processing) instead, as it provides better reliability for large files and avoids timeout issues.
     *
     * The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.
     *
     * For more details, see the [Parse File guide](https://docs.extend.ai/2026-02-09/product/parsing/parse).
     *
     * @param {Extend.ParseRequest} request
     * @param {ExtendClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.PaymentRequiredError}
     * @throws {@link Extend.ForbiddenError}
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.UnprocessableEntityError}
     * @throws {@link Extend.TooManyRequestsError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.parse({
     *         file: {
     *             url: "url"
     *         }
     *     })
     */
    public parse(
        request: Extend.ParseRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.ParseRun> {
        return core.HttpResponsePromise.fromPromise(this.__parse(request, requestOptions));
    }

    private async __parse(
        request: Extend.ParseRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.ParseRun>> {
        const { responseType, ..._body } = request;
        const _queryParams: Record<string, unknown> = {
            responseType: responseType != null ? responseType : undefined,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-extend-api-version": requestOptions?.extendApiVersion ?? "2026-02-09" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "parse",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 300) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.ParseRun, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Extend.PaymentRequiredError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Extend.ForbiddenError(_response.error.body as Extend.ApiError, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Extend.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/parse");
    }

    /**
     * Edit a file synchronously, waiting for the result before returning. This endpoint has a **5-minute timeout** — if processing takes longer, the request will fail.
     *
     * **Note:** This endpoint is intended for onboarding and testing only. For production workloads, use `POST /edit_runs` with [polling or webhooks](https://docs.extend.ai/2026-02-09/developers/async-processing) instead, as it provides better reliability for large files and avoids timeout issues.
     *
     * The Edit endpoint allows you to detect and fill form fields in PDF documents.
     *
     * For more details, see the [Edit File guide](https://docs.extend.ai/2026-02-09/product/editing/edit).
     *
     * @param {Extend.EditRequest} request
     * @param {ExtendClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.PaymentRequiredError}
     * @throws {@link Extend.ForbiddenError}
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.UnprocessableEntityError}
     * @throws {@link Extend.TooManyRequestsError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.edit({
     *         file: {
     *             url: "url"
     *         }
     *     })
     */
    public edit(
        request: Extend.EditRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.EditRun> {
        return core.HttpResponsePromise.fromPromise(this.__edit(request, requestOptions));
    }

    private async __edit(
        request: Extend.EditRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.EditRun>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-extend-api-version": requestOptions?.extendApiVersion ?? "2026-02-09" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "edit",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 300) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.EditRun, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Extend.PaymentRequiredError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Extend.ForbiddenError(_response.error.body as Extend.ApiError, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Extend.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/edit");
    }

    /**
     * Extract structured data from a file synchronously, waiting for the result before returning. This endpoint has a **5-minute timeout** — if processing takes longer, the request will fail.
     *
     * **Note:** This endpoint is intended for onboarding and testing only. For production workloads, use `POST /extract_runs` with [polling or webhooks](https://docs.extend.ai/2026-02-09/developers/async-processing) instead, as it provides better reliability for large files and avoids timeout issues.
     *
     * The Extract endpoint allows you to extract structured data from files using an existing extractor or an inline configuration.
     *
     * For more details, see the [Extract File guide](https://docs.extend.ai/2026-02-09/product/extracting/extract).
     *
     * @param {Extend.ExtractRequest} request
     * @param {ExtendClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.PaymentRequiredError}
     * @throws {@link Extend.ForbiddenError}
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.UnprocessableEntityError}
     * @throws {@link Extend.TooManyRequestsError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.extract({
     *         file: {
     *             url: "url"
     *         }
     *     })
     */
    public extract(
        request: Extend.ExtractRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.ExtractRun> {
        return core.HttpResponsePromise.fromPromise(this.__extract(request, requestOptions));
    }

    private async __extract(
        request: Extend.ExtractRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.ExtractRun>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-extend-api-version": requestOptions?.extendApiVersion ?? "2026-02-09" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "extract",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 300) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.ExtractRun, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Extend.PaymentRequiredError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Extend.ForbiddenError(_response.error.body as Extend.ApiError, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Extend.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/extract");
    }

    /**
     * Classify a document synchronously, waiting for the result before returning. This endpoint has a **5-minute timeout** — if processing takes longer, the request will fail.
     *
     * **Note:** This endpoint is intended for onboarding and testing only. For production workloads, use `POST /classify_runs` with [polling or webhooks](https://docs.extend.ai/2026-02-09/developers/async-processing) instead, as it provides better reliability for large files and avoids timeout issues.
     *
     * The Classify endpoint allows you to classify documents using an existing classifier or an inline configuration.
     *
     * For more details, see the [Classify File guide](https://docs.extend.ai/2026-02-09/product/classifying/classify).
     *
     * @param {Extend.ClassifyRequest} request
     * @param {ExtendClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.PaymentRequiredError}
     * @throws {@link Extend.ForbiddenError}
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.UnprocessableEntityError}
     * @throws {@link Extend.TooManyRequestsError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.classify({
     *         file: {
     *             url: "url"
     *         }
     *     })
     */
    public classify(
        request: Extend.ClassifyRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.ClassifyRun> {
        return core.HttpResponsePromise.fromPromise(this.__classify(request, requestOptions));
    }

    private async __classify(
        request: Extend.ClassifyRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.ClassifyRun>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-extend-api-version": requestOptions?.extendApiVersion ?? "2026-02-09" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "classify",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 300) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.ClassifyRun, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Extend.PaymentRequiredError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Extend.ForbiddenError(_response.error.body as Extend.ApiError, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Extend.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/classify");
    }

    /**
     * Split a document synchronously, waiting for the result before returning. This endpoint has a **5-minute timeout** — if processing takes longer, the request will fail.
     *
     * **Note:** This endpoint is intended for onboarding and testing only. For production workloads, use `POST /split_runs` with [polling or webhooks](https://docs.extend.ai/2026-02-09/developers/async-processing) instead, as it provides better reliability for large files and avoids timeout issues.
     *
     * The Split endpoint allows you to split documents into multiple parts using an existing splitter or an inline configuration.
     *
     * For more details, see the [Split File guide](https://docs.extend.ai/2026-02-09/product/splitting/split).
     *
     * @param {Extend.SplitRequest} request
     * @param {ExtendClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.PaymentRequiredError}
     * @throws {@link Extend.ForbiddenError}
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.UnprocessableEntityError}
     * @throws {@link Extend.TooManyRequestsError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.split({
     *         file: {
     *             url: "url"
     *         }
     *     })
     */
    public split(
        request: Extend.SplitRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.SplitRun> {
        return core.HttpResponsePromise.fromPromise(this.__split(request, requestOptions));
    }

    private async __split(
        request: Extend.SplitRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.SplitRun>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-extend-api-version": requestOptions?.extendApiVersion ?? "2026-02-09" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "split",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 300) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.SplitRun, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Extend.PaymentRequiredError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Extend.ForbiddenError(_response.error.body as Extend.ApiError, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Extend.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/split");
    }
}
