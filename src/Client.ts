/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "./environments";
import * as core from "./core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "./core/headers";
import * as Extend from "./api/index";
import * as errors from "./errors/index";
import { WorkflowRun } from "./api/resources/workflowRun/client/Client";
import { BatchWorkflowRun } from "./api/resources/batchWorkflowRun/client/Client";
import { ProcessorRun } from "./api/resources/processorRun/client/Client";
import { Processor } from "./api/resources/processor/client/Client";
import { ProcessorVersion } from "./api/resources/processorVersion/client/Client";
import { ParserRun } from "./api/resources/parserRun/client/Client";
import { File_ } from "./api/resources/file/client/Client";
import { EvaluationSet } from "./api/resources/evaluationSet/client/Client";
import { EvaluationSetItem } from "./api/resources/evaluationSetItem/client/Client";
import { WorkflowRunOutput } from "./api/resources/workflowRunOutput/client/Client";
import { BatchProcessorRun } from "./api/resources/batchProcessorRun/client/Client";
import { Workflow } from "./api/resources/workflow/client/Client";

export declare namespace ExtendClient {
    export interface Options {
        environment?: core.Supplier<environments.ExtendEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token: core.Supplier<core.BearerToken>;
        /** Override the x-extend-api-version header */
        extendApiVersion?: "2025-04-21";
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the x-extend-api-version header */
        extendApiVersion?: "2025-04-21";
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class ExtendClient {
    protected readonly _options: ExtendClient.Options;
    protected _workflowRun: WorkflowRun | undefined;
    protected _batchWorkflowRun: BatchWorkflowRun | undefined;
    protected _processorRun: ProcessorRun | undefined;
    protected _processor: Processor | undefined;
    protected _processorVersion: ProcessorVersion | undefined;
    protected _parserRun: ParserRun | undefined;
    protected _file: File_ | undefined;
    protected _evaluationSet: EvaluationSet | undefined;
    protected _evaluationSetItem: EvaluationSetItem | undefined;
    protected _workflowRunOutput: WorkflowRunOutput | undefined;
    protected _batchProcessorRun: BatchProcessorRun | undefined;
    protected _workflow: Workflow | undefined;

    constructor(_options: ExtendClient.Options) {
        this._options = {
            ..._options,
            headers: mergeHeaders(
                {
                    "x-extend-api-version": _options?.extendApiVersion ?? "2025-04-21",
                    "X-Fern-Language": "JavaScript",
                    "X-Fern-SDK-Name": "extend-ai",
                    "X-Fern-SDK-Version": "0.0.5",
                    "User-Agent": "extend-ai/0.0.5",
                    "X-Fern-Runtime": core.RUNTIME.type,
                    "X-Fern-Runtime-Version": core.RUNTIME.version,
                },
                _options?.headers,
            ),
        };
    }

    public get workflowRun(): WorkflowRun {
        return (this._workflowRun ??= new WorkflowRun(this._options));
    }

    public get batchWorkflowRun(): BatchWorkflowRun {
        return (this._batchWorkflowRun ??= new BatchWorkflowRun(this._options));
    }

    public get processorRun(): ProcessorRun {
        return (this._processorRun ??= new ProcessorRun(this._options));
    }

    public get processor(): Processor {
        return (this._processor ??= new Processor(this._options));
    }

    public get processorVersion(): ProcessorVersion {
        return (this._processorVersion ??= new ProcessorVersion(this._options));
    }

    public get parserRun(): ParserRun {
        return (this._parserRun ??= new ParserRun(this._options));
    }

    public get file(): File_ {
        return (this._file ??= new File_(this._options));
    }

    public get evaluationSet(): EvaluationSet {
        return (this._evaluationSet ??= new EvaluationSet(this._options));
    }

    public get evaluationSetItem(): EvaluationSetItem {
        return (this._evaluationSetItem ??= new EvaluationSetItem(this._options));
    }

    public get workflowRunOutput(): WorkflowRunOutput {
        return (this._workflowRunOutput ??= new WorkflowRunOutput(this._options));
    }

    public get batchProcessorRun(): BatchProcessorRun {
        return (this._batchProcessorRun ??= new BatchProcessorRun(this._options));
    }

    public get workflow(): Workflow {
        return (this._workflow ??= new Workflow(this._options));
    }

    /**
     * Parse files to get cleaned, chunked target content (e.g. markdown).
     *
     * The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.
     *
     * For more details, see the [Parse File guide](/product/parsing/parse).
     *
     * @param {Extend.ParseRequest} request
     * @param {ExtendClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.UnprocessableEntityError}
     *
     * @example
     *     await client.parse({
     *         file: {}
     *     })
     */
    public parse(
        request: Extend.ParseRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.ParserRun> {
        return core.HttpResponsePromise.fromPromise(this.__parse(request, requestOptions));
    }

    private async __parse(
        request: Extend.ParseRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.ParserRun>> {
        const { responseType, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (responseType != null) {
            _queryParams["responseType"] = responseType;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version": requestOptions?.extendApiVersion ?? "2025-04-21",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "parse",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.ParserRun, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /parse.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Parse files **asynchronously** to get cleaned, chunked target content (e.g. markdown).
     *
     * The Parse Async endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.
     *
     * Parse files asynchronously and get a parser run ID that can be used to check status and retrieve results with the [Get Parser Run](https://docs.extend.ai/2025-04-21/developers/api-reference/parse-endpoints/get-parser-run) endpoint.
     *
     * This is useful for:
     * * Large files that may take longer to process
     * * Avoiding timeout issues with synchronous parsing.
     *
     * For more details, see the [Parse File guide](/product/parsing/parse).
     *
     * @param {Extend.ParseAsyncRequest} request
     * @param {ExtendClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     *
     * @example
     *     await client.parseAsync({
     *         file: {}
     *     })
     */
    public parseAsync(
        request: Extend.ParseAsyncRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.ParserRunStatus> {
        return core.HttpResponsePromise.fromPromise(this.__parseAsync(request, requestOptions));
    }

    private async __parseAsync(
        request: Extend.ParseAsyncRequest,
        requestOptions?: ExtendClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.ParserRunStatus>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version": requestOptions?.extendApiVersion ?? "2025-04-21",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "parse/async",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.ParserRunStatus, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /parse/async.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
