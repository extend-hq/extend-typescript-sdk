/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Extend from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace ProcessorEndpoints {
    export interface Options {
        environment?: core.Supplier<environments.ExtendEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token: core.Supplier<core.BearerToken>;
        /** Override the x-extend-api-version header */
        extendApiVersion?: core.Supplier<Extend.ApiVersionEnum | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the x-extend-api-version header */
        extendApiVersion?: Extend.ApiVersionEnum | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

export class ProcessorEndpoints {
    constructor(protected readonly _options: ProcessorEndpoints.Options) {}

    /**
     * Run processors (extraction, classification, splitting, etc.) on a given document.
     *
     * In general, the recommended way to integrate with Extend in production is via workflows, using the [Run Workflow](/developers/api-reference/workflow-endpoints/run-workflow) endpoint. This is due to several factors:
     * * file parsing/pre-processing will automatically be reused across multiple processors, which will give you simplicity and cost savings given that many use cases will require multiple processors to be run on the same document.
     * * workflows provide dedicated human in the loop document review, when needed.
     * * workflows allow you to model and manage your pipeline with a single endpoint and corresponding UI for modeling and monitoring.
     *
     * However, there are a number of legitimate use cases and systems where it might be easier to model the pipeline via code and run processors directly. This endpoint is provided for this purpose.
     *
     * Similar to workflow runs, processor runs are asynchronous and will return a status of `PROCESSING` until the run is complete. You can [configure webhooks](/developers/webhooks/configuration) to receive notifications when a processor run is complete or failed.
     *
     * @param {Extend.PostProcessorRunsRequest} request
     * @param {ProcessorEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.processorEndpoints.runProcessor({
     *         processorId: "processor_id_here"
     *     })
     */
    public runProcessor(
        request: Extend.PostProcessorRunsRequest,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostProcessorRunsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__runProcessor(request, requestOptions));
    }

    private async __runProcessor(
        request: Extend.PostProcessorRunsRequest,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostProcessorRunsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "processor_runs",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.16",
                "User-Agent": "extendai/0.0.16",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.PostProcessorRunsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /processor_runs.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve details about a specific processor run, including its status, outputs, and any edits made during review.
     *
     * A common use case for this endpoint is to poll for the status and final output of an async processor run when using the [Run Processor](/developers/api-reference/processor-endpoints/run-processor) endpoint. For instance, if you do not want to not configure webhooks to receive the output via completion/failure events.
     *
     * @param {string} id - The unique identifier for this processor run. The ID will start with "dpr_". This can be fetched from the API response when running a processor, or from the Extend UI in the "history" tab of a processor.
     *
     *                      Example: `"dpr_Xj8mK2pL9nR4vT7qY5wZ"`
     * @param {ProcessorEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.processorEndpoints.getProcessorRun("processor_run_id_here")
     */
    public getProcessorRun(
        id: string,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.GetProcessorRunsIdResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getProcessorRun(id, requestOptions));
    }

    private async __getProcessorRun(
        id: string,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.GetProcessorRunsIdResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `processor_runs/${encodeURIComponent(id)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.16",
                "User-Agent": "extendai/0.0.16",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.GetProcessorRunsIdResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling GET /processor_runs/{id}.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new processor in Extend, optionally cloning from an existing processor
     *
     * @param {Extend.PostProcessorsRequest} request
     * @param {ProcessorEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.processorEndpoints.createProcessor({
     *         name: "My Processor Name",
     *         type: "EXTRACT"
     *     })
     */
    public createProcessor(
        request: Extend.PostProcessorsRequest,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostProcessorsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createProcessor(request, requestOptions));
    }

    private async __createProcessor(
        request: Extend.PostProcessorsRequest,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostProcessorsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "processors",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.16",
                "User-Agent": "extendai/0.0.16",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.PostProcessorsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /processors.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve a specific version of a processor in Extend
     *
     * @param {string} processorId - The ID of the processor. The ID will start with "dp_".
     *
     *                               Example: `"dp_Xj8mK2pL9nR4vT7qY5wZ"`
     * @param {string} processorVersionId - The ID of the specific processor version to retrieve. The ID will start with "dpv_".
     *
     *                                      Example: `"dpv_QYk6jgHA_8CsO8rVWhyNC"`
     * @param {ProcessorEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.processorEndpoints.getProcessorVersion("processor_id_here", "processor_version_id_here")
     */
    public getProcessorVersion(
        processorId: string,
        processorVersionId: string,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.GetProcessorsProcessorIdVersionsProcessorVersionIdResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__getProcessorVersion(processorId, processorVersionId, requestOptions),
        );
    }

    private async __getProcessorVersion(
        processorId: string,
        processorVersionId: string,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.GetProcessorsProcessorIdVersionsProcessorVersionIdResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `processors/${encodeURIComponent(processorId)}/versions/${encodeURIComponent(processorVersionId)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.16",
                "User-Agent": "extendai/0.0.16",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.GetProcessorsProcessorIdVersionsProcessorVersionIdResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError(
                    "Timeout exceeded when calling GET /processors/{processorId}/versions/{processorVersionId}.",
                );
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This endpoint allows you to fetch all versions of a given processor, including the current `draft` version.
     *
     * Versions are typically returned in descending order of creation (newest first), but this should be confirmed in the actual implementation.
     * The `draft` version is the latest unpublished version of the processor, which can be published to create a new version. It might not have any changes from the last published version.
     *
     * @param {string} id - The ID of the processor to retrieve versions for. The ID will start with "dp_".
     *
     *                      Example: `"dp_Xj8mK2pL9nR4vT7qY5wZ"`
     * @param {ProcessorEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.processorEndpoints.listProcessorVersions("processor_id_here")
     */
    public listProcessorVersions(
        id: string,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.GetProcessorsIdVersionsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listProcessorVersions(id, requestOptions));
    }

    private async __listProcessorVersions(
        id: string,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.GetProcessorsIdVersionsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `processors/${encodeURIComponent(id)}/versions`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.16",
                "User-Agent": "extendai/0.0.16",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.GetProcessorsIdVersionsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling GET /processors/{id}/versions.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This endpoint allows you to publish a new version of an existing processor. Publishing a new version creates a snapshot of the processor's current configuration and makes it available for use in workflows.
     *
     * Publishing a new version does not automatically update existing workflows using this processor. You may need to manually update workflows to use the new version if desired.
     *
     * @param {string} id - The ID of the processor to publish a new version for. The ID will start with "dp_".
     *
     *                      Example: `"dp_Xj8mK2pL9nR4vT7qY5wZ"`
     * @param {Extend.PostProcessorsIdPublishRequest} request
     * @param {ProcessorEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     *
     * @example
     *     await client.processorEndpoints.publishProcessorVersion("processor_id_here", {
     *         releaseType: "major"
     *     })
     */
    public publishProcessorVersion(
        id: string,
        request: Extend.PostProcessorsIdPublishRequest,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostProcessorsIdPublishResponse> {
        return core.HttpResponsePromise.fromPromise(this.__publishProcessorVersion(id, request, requestOptions));
    }

    private async __publishProcessorVersion(
        id: string,
        request: Extend.PostProcessorsIdPublishRequest,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostProcessorsIdPublishResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `processors/${encodeURIComponent(id)}/publish`,
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.16",
                "User-Agent": "extendai/0.0.16",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.PostProcessorsIdPublishResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /processors/{id}/publish.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve details about a batch processor run, including evaluation runs
     *
     * @param {string} id - The unique identifier of the batch processor run to retrieve. The ID will always start with "bpr_".
     *
     *                      Example: `"bpr_Xj8mK2pL9nR4vT7qY5wZ"`
     * @param {ProcessorEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.processorEndpoints.getBatchProcessorRun("batch_processor_run_id_here")
     */
    public getBatchProcessorRun(
        id: string,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.GetBatchProcessorRunsIdResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getBatchProcessorRun(id, requestOptions));
    }

    private async __getBatchProcessorRun(
        id: string,
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.GetBatchProcessorRunsIdResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `batch_processor_runs/${encodeURIComponent(id)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.16",
                "User-Agent": "extendai/0.0.16",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.GetBatchProcessorRunsIdResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling GET /batch_processor_runs/{id}.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update an existing processor in Extend
     *
     * @param {string} id - The ID of the processor to update. The ID will start with "dp_".
     *
     *                      Example: `"dp_Xj8mK2pL9nR4vT7qY5wZ"`
     * @param {Extend.PostProcessorsIdRequest} request
     * @param {ProcessorEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.processorEndpoints.updateProcessor("processor_id_here")
     */
    public updateProcessor(
        id: string,
        request: Extend.PostProcessorsIdRequest = {},
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostProcessorsIdResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateProcessor(id, request, requestOptions));
    }

    private async __updateProcessor(
        id: string,
        request: Extend.PostProcessorsIdRequest = {},
        requestOptions?: ProcessorEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostProcessorsIdResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `processors/${encodeURIComponent(id)}`,
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.16",
                "User-Agent": "extendai/0.0.16",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.PostProcessorsIdResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /processors/{id}.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
