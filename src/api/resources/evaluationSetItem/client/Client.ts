/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Extend from "../../../index";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers";
import * as errors from "../../../../errors/index";

export declare namespace EvaluationSetItem {
    export interface Options {
        environment?: core.Supplier<environments.ExtendEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the x-extend-api-version header */
        extendApiVersion?: "2025-04-21";
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the x-extend-api-version header */
        extendApiVersion?: "2025-04-21";
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }
}

export class EvaluationSetItem {
    protected readonly _options: EvaluationSetItem.Options;

    constructor(_options: EvaluationSetItem.Options = {}) {
        this._options = _options;
    }

    /**
     * List all items in a specific evaluation set. Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given processor in Extend.
     *
     * This endpoint returns a paginated response. You can use the `nextPageToken` to fetch subsequent results.
     *
     * @param {string} id - The ID of the evaluation set to retrieve items for.
     *
     *                      Example: `"ev_2LcgeY_mp2T5yPaEuq5Lw"`
     * @param {Extend.EvaluationSetItemListRequest} request
     * @param {EvaluationSetItem.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.evaluationSetItem.list("evaluation_set_id_here", {
     *         sortBy: "updatedAt",
     *         sortDir: "asc",
     *         nextPageToken: "xK9mLPqRtN3vS8wF5hB2cQ==:zWvUxYjM4nKpL7aDgE9HbTcR2mAyX3/Q+CNkfBSw1dZ=",
     *         maxPageSize: 1
     *     })
     */
    public list(
        id: string,
        request: Extend.EvaluationSetItemListRequest = {},
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): core.HttpResponsePromise<Extend.EvaluationSetItemListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__list(id, request, requestOptions));
    }

    private async __list(
        id: string,
        request: Extend.EvaluationSetItemListRequest = {},
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.EvaluationSetItemListResponse>> {
        const { sortBy, sortDir, nextPageToken, maxPageSize } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (sortBy != null) {
            _queryParams["sortBy"] = sortBy;
        }

        if (sortDir != null) {
            _queryParams["sortDir"] = sortDir;
        }

        if (nextPageToken != null) {
            _queryParams["nextPageToken"] = nextPageToken;
        }

        if (maxPageSize != null) {
            _queryParams["maxPageSize"] = maxPageSize.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version": requestOptions?.extendApiVersion ?? "2025-04-21",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `evaluation_sets/${encodeURIComponent(id)}/items`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.EvaluationSetItemListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling GET /evaluation_sets/{id}/items.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Evaluation set items are the individual files and expected outputs that are used to evaluate the performance of a given processor in Extend. This endpoint will create a new evaluation set item in Extend, which will be used during an evaluation run.
     *
     * Best Practices for Outputs in Evaluation Sets:
     * - **Configure First, Output Later**
     *   - Always create and finalize your processor configuration before creating evaluation sets
     *   - Field IDs in outputs must match those defined in your processor configuration
     * - **Type Consistency**
     *   - Ensure output types exactly match your processor configuration
     *   - For example, if a field is configured as "currency", don't submit a simple number value
     * - **Field IDs**
     *   - Use the exact field IDs from your processor configuration
     *   - Create your own semantic IDs instead in the configs for each field/type instead of using the generated ones
     * - **Value**
     *   - Remember that all results are inside the value key of a result object, except the values within nested structures.
     *
     * @param {Extend.EvaluationSetItemCreateRequest} request
     * @param {EvaluationSetItem.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     *
     * @example
     *     await client.evaluationSetItem.create({
     *         evaluationSetId: "evaluation_set_id_here",
     *         fileId: "file_id_here",
     *         expectedOutput: {
     *             value: {
     *                 "key": "value"
     *             }
     *         }
     *     })
     */
    public create(
        request: Extend.EvaluationSetItemCreateRequest,
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): core.HttpResponsePromise<Extend.EvaluationSetItemCreateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Extend.EvaluationSetItemCreateRequest,
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.EvaluationSetItemCreateResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version": requestOptions?.extendApiVersion ?? "2025-04-21",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "evaluation_set_items",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.EvaluationSetItemCreateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /evaluation_set_items.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * If you need to change the expected output for a given evaluation set item, you can use this endpoint to update the item. This can be useful if you need to correct an error in the expected output or if the output of the processor has changed.
     *
     * @param {string} id - The ID of the evaluation set item to update.
     *
     *                      Example: `"evi_kR9mNP12Qw4yTv8BdR3H"`
     * @param {Extend.EvaluationSetItemUpdateRequest} request
     * @param {EvaluationSetItem.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.evaluationSetItem.update("evaluation_set_item_id_here", {
     *         expectedOutput: {
     *             value: {
     *                 "key": "value"
     *             }
     *         }
     *     })
     */
    public update(
        id: string,
        request: Extend.EvaluationSetItemUpdateRequest,
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): core.HttpResponsePromise<Extend.EvaluationSetItemUpdateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
    }

    private async __update(
        id: string,
        request: Extend.EvaluationSetItemUpdateRequest,
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.EvaluationSetItemUpdateResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version": requestOptions?.extendApiVersion ?? "2025-04-21",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `evaluation_set_items/${encodeURIComponent(id)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.EvaluationSetItemUpdateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /evaluation_set_items/{id}.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete an evaluation set item from an evaluation set. This operation is permanent and cannot be undone.
     *
     * This endpoint can be used to remove individual items from an evaluation set when they are no longer needed or if they were added in error.
     *
     * @param {string} id - The ID of the evaluation set item to delete.
     *
     *                      Example: `"evi_kR9mNP12Qw4yTv8BdR3H"`
     * @param {EvaluationSetItem.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.evaluationSetItem.delete("evaluation_set_item_id_here")
     */
    public delete(
        id: string,
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): core.HttpResponsePromise<Extend.EvaluationSetItemDeleteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
    }

    private async __delete(
        id: string,
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.EvaluationSetItemDeleteResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version": requestOptions?.extendApiVersion ?? "2025-04-21",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `evaluation_set_items/${encodeURIComponent(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.EvaluationSetItemDeleteResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(
                        _response.error.body as Extend.ExtendError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling DELETE /evaluation_set_items/{id}.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * If you have a large number of files that you need to add to an evaluation set, you can use this endpoint to create multiple evaluation set items at once. This can be useful if you have a large dataset that you need to evaluate the performance of a processor against.
     *
     * Note: you still need to create each File first using the file API.
     *
     * @param {Extend.EvaluationSetItemCreateBatchRequest} request
     * @param {EvaluationSetItem.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     *
     * @example
     *     await client.evaluationSetItem.createBatch({
     *         evaluationSetId: "evaluation_set_id_here",
     *         items: [{
     *                 fileId: "file_id_here",
     *                 expectedOutput: {
     *                     value: {
     *                         "key": "value"
     *                     }
     *                 }
     *             }]
     *     })
     */
    public createBatch(
        request: Extend.EvaluationSetItemCreateBatchRequest,
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): core.HttpResponsePromise<Extend.EvaluationSetItemCreateBatchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createBatch(request, requestOptions));
    }

    private async __createBatch(
        request: Extend.EvaluationSetItemCreateBatchRequest,
        requestOptions?: EvaluationSetItem.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.EvaluationSetItemCreateBatchResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version": requestOptions?.extendApiVersion ?? "2025-04-21",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "evaluation_set_items/bulk",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.EvaluationSetItemCreateBatchResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /evaluation_set_items/bulk.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
