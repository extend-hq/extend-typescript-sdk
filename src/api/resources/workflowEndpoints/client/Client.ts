/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Extend from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace WorkflowEndpoints {
    export interface Options {
        environment?: core.Supplier<environments.ExtendEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token: core.Supplier<core.BearerToken>;
        /** Override the x-extend-api-version header */
        extendApiVersion?: core.Supplier<Extend.ApiVersionEnum | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the x-extend-api-version header */
        extendApiVersion?: Extend.ApiVersionEnum | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

export class WorkflowEndpoints {
    constructor(protected readonly _options: WorkflowEndpoints.Options) {}

    /**
     * List runs of a Workflow. Workflows are sequences of steps that process files and data in a specific order to achieve a desired outcome. A WorkflowRun represents a single execution of a workflow against a file.
     *
     * @param {Extend.GetWorkflowRunsRequest} request
     * @param {WorkflowEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     *
     * @example
     *     await client.workflowEndpoints.listWorkflowRuns({
     *         nextPageToken: "xK9mLPqRtN3vS8wF5hB2cQ==:zWvUxYjM4nKpL7aDgE9HbTcR2mAyX3/Q+CNkfBSw1dZ="
     *     })
     */
    public listWorkflowRuns(
        request: Extend.GetWorkflowRunsRequest = {},
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.GetWorkflowRunsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listWorkflowRuns(request, requestOptions));
    }

    private async __listWorkflowRuns(
        request: Extend.GetWorkflowRunsRequest = {},
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.GetWorkflowRunsResponse>> {
        const { status, workflowId, fileNameContains, sortBy, sortDir, nextPageToken, maxPageSize } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (status != null) {
            _queryParams["status"] = status;
        }

        if (workflowId != null) {
            _queryParams["workflowId"] = workflowId;
        }

        if (fileNameContains != null) {
            _queryParams["fileNameContains"] = fileNameContains;
        }

        if (sortBy != null) {
            _queryParams["sortBy"] = sortBy;
        }

        if (sortDir != null) {
            _queryParams["sortDir"] = sortDir;
        }

        if (nextPageToken != null) {
            _queryParams["nextPageToken"] = nextPageToken;
        }

        if (maxPageSize != null) {
            _queryParams["maxPageSize"] = maxPageSize.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "workflow_runs",
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.11",
                "User-Agent": "extendai/0.0.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.GetWorkflowRunsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling GET /workflow_runs.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Run a Workflow with files. A Workflow is a sequence of steps that process files and data in a specific order to achieve a desired outcome. A WorkflowRun will be created for each file processed. A WorkflowRun represents a single execution of a workflow against a file.
     *
     * @param {Extend.PostWorkflowRunsRequest} request
     * @param {WorkflowEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     *
     * @example
     *     await client.workflowEndpoints.runWorkflow({
     *         workflowId: "workflow_id_here"
     *     })
     */
    public runWorkflow(
        request: Extend.PostWorkflowRunsRequest,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostWorkflowRunsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__runWorkflow(request, requestOptions));
    }

    private async __runWorkflow(
        request: Extend.PostWorkflowRunsRequest,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostWorkflowRunsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "workflow_runs",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.11",
                "User-Agent": "extendai/0.0.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.PostWorkflowRunsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /workflow_runs.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Once a workflow has been run, you can check the status and output of a specific WorkflowRun.
     *
     * @param {string} workflowRunId - The ID of the WorkflowRun that was outputted after a Workflow was run through the API. The ID will start with "workflow_run". This ID can be found when creating a WorkflowRun via API, or when viewing the "history" tab of a workflow on the Extend platform.
     *
     *                                 Example: `"workflow_run_8k9m-xyzAB_Pqrst-Nvw4"`
     * @param {WorkflowEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.workflowEndpoints.getWorkflowRun("workflow_run_id_here")
     */
    public getWorkflowRun(
        workflowRunId: string,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.GetWorkflowRunsWorkflowRunIdResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getWorkflowRun(workflowRunId, requestOptions));
    }

    private async __getWorkflowRun(
        workflowRunId: string,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.GetWorkflowRunsWorkflowRunIdResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `workflow_runs/${encodeURIComponent(workflowRunId)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.11",
                "User-Agent": "extendai/0.0.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.GetWorkflowRunsWorkflowRunIdResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError(
                    "Timeout exceeded when calling GET /workflow_runs/{workflowRunId}.",
                );
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * You can update the name and metadata of an in progress WorkflowRun at any time using this endpoint.
     *
     * @param {string} workflowRunId - The ID of the WorkflowRun. This ID will start with "workflow_run". This ID can be found in the API response when creating a Workflow Run, or in the "history" tab of a workflow on the Extend platform.
     *
     *                                 Example: `"workflow_run_8k9m-xyzAB_Pqrst-Nvw4"`
     * @param {Extend.PostWorkflowRunsWorkflowRunIdRequest} request
     * @param {WorkflowEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.workflowEndpoints.updateWorkflowRun("workflow_run_id_here")
     */
    public updateWorkflowRun(
        workflowRunId: string,
        request: Extend.PostWorkflowRunsWorkflowRunIdRequest = {},
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostWorkflowRunsWorkflowRunIdResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateWorkflowRun(workflowRunId, request, requestOptions));
    }

    private async __updateWorkflowRun(
        workflowRunId: string,
        request: Extend.PostWorkflowRunsWorkflowRunIdRequest = {},
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostWorkflowRunsWorkflowRunIdResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `workflow_runs/${encodeURIComponent(workflowRunId)}`,
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.11",
                "User-Agent": "extendai/0.0.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.PostWorkflowRunsWorkflowRunIdResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError(
                    "Timeout exceeded when calling POST /workflow_runs/{workflowRunId}.",
                );
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This endpoint allows you to efficiently initiate large batches of workflow runs in a single request (up to 1,000 in a single request, but you can queue up multiple batches in rapid succession). It accepts an array of inputs, each containing a file and metadata pair. The primary use case for this endpoint is for doing large bulk runs of >1000 files at a time that can process over the course of a few hours without needing to manage rate limits that would likely occur using the primary run endpoint.
     *
     * Unlike the single [Run Workflow](/developers/api-reference/workflow-endpoints/run-workflow) endpoint which returns the details of the created workflow runs immediately, this batch endpoint returns a `batchId`.
     *
     * Our recommended usage pattern is to integrate with [Webhooks](/developers/webhooks/configuration) for consuming results, using the `metadata` and `batchId` to match up results to the original inputs in your downstream systems. However, you can integrate in a polling mechanism by using a combination of the [List Workflow Runs](/developers/workflow-endpoints/list-workflow-runs) endpoint to fetch all runs via a batch, and then [Get Workflow Run](/developers/workflow-endpoints/get-workflow-run) to fetch the full outputs each run.
     *
     * **Processing and Monitoring:**
     * Upon successful submission, the endpoint returns a `batchId`. The individual workflow runs are then queued for processing.
     *
     * - **Monitoring:** Track the progress and consume results of individual runs using [Webhooks](/developers/webhooks/configuration). Subscribe to events like `workflow_run.completed`, `workflow_run.failed`, etc. The webhook payload for these events will include the corresponding `batchId` and the `metadata` you provided for each input.
     * - **Fetching Results:** You can also use the [List Workflow Runs](/developers/api-reference/workflow-endpoints/list-workflow-runs) endpoint and filter using the `batchId` query param.
     *
     * **Error Responses**
     *
     * Common errors include:
     *
     * **400 Bad Request**: Invalid request body (e.g., missing required fields, array size limits exceeded, issues with `fileUrl` or `fileId`). The response body will contain an `error` message detailing the specific validation issues. Can also indicate issues accessing a provided `fileUrl`.
     *
     * **401 Unauthorized**: Missing or invalid API token.
     *
     * **403 Forbidden**: The API token does not have permission to access the specified workflow.
     *
     * **404 Not Found**: The specified `workflowId` or `version` does not exist.
     *
     * **429 Too Many Requests**: The request was rate limited. Please try again later.
     *
     * **500 Internal Server Error**: An unexpected error occurred on the server.
     *
     * @param {Extend.PostWorkflowRunsBatchRequest} request
     * @param {WorkflowEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.workflowEndpoints.batchRunWorkflow({
     *         workflowId: "workflow_id_here",
     *         inputs: [{}]
     *     })
     */
    public batchRunWorkflow(
        request: Extend.PostWorkflowRunsBatchRequest,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostWorkflowRunsBatchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__batchRunWorkflow(request, requestOptions));
    }

    private async __batchRunWorkflow(
        request: Extend.PostWorkflowRunsBatchRequest,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostWorkflowRunsBatchResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "workflow_runs/batch",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.11",
                "User-Agent": "extendai/0.0.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.PostWorkflowRunsBatchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /workflow_runs/batch.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Use this endpoint to submit corrected outputs for a WorkflowRun for future processor evaluation and tuning in Extend.
     *
     * If you are using our Human-in-the-loop workflow review, then we already will be collecting your operator submitted corrections. However, if you are receiving data via the API without human review, there could be incorrect outputs that you would like to correct for future usage in evaluation and tuning within the Extend platform. This endpoint allows you to submit corrected outputs for a WorkflowRun, by providing the correct output for a given output ID.
     *
     * The output ID, would be found in a given entry within the outputs arrays of a Workflow Run payload. The ID would look something like `dpr_gwkZZNRrPgkjcq0y-***`.
     *
     * @param {string} workflowRunId
     * @param {string} outputId
     * @param {Extend.PostWorkflowRunsWorkflowRunIdOutputsOutputIdRequest} request
     * @param {WorkflowEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.NotFoundError}
     *
     * @example
     *     await client.workflowEndpoints.correctWorkflowRunOutputs("workflow_run_id_here", "output_id_here", {
     *         reviewedOutput: {
     *             value: {
     *                 "key": "value"
     *             },
     *             metadata: {
     *                 "key": {}
     *             }
     *         }
     *     })
     */
    public correctWorkflowRunOutputs(
        workflowRunId: string,
        outputId: string,
        request: Extend.PostWorkflowRunsWorkflowRunIdOutputsOutputIdRequest,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostWorkflowRunsWorkflowRunIdOutputsOutputIdResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__correctWorkflowRunOutputs(workflowRunId, outputId, request, requestOptions),
        );
    }

    private async __correctWorkflowRunOutputs(
        workflowRunId: string,
        outputId: string,
        request: Extend.PostWorkflowRunsWorkflowRunIdOutputsOutputIdRequest,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostWorkflowRunsWorkflowRunIdOutputsOutputIdResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `workflow_runs/${encodeURIComponent(workflowRunId)}/outputs/${encodeURIComponent(outputId)}`,
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.11",
                "User-Agent": "extendai/0.0.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Extend.PostWorkflowRunsWorkflowRunIdOutputsOutputIdResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError(
                    "Timeout exceeded when calling POST /workflow_runs/{workflowRunId}/outputs/{outputId}.",
                );
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new workflow in Extend. Workflows are sequences of steps that process files and data in a specific order to achieve a desired outcome.
     *
     * This endpoint will create a new workflow in Extend, which can then be configured and deployed. Typically, workflows are created from our UI, however this endpoint can be used to create workflows programmatically. Configuration of the flow still needs to be done in the dashboard.
     *
     * @param {Extend.PostWorkflowsRequest} request
     * @param {WorkflowEndpoints.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     *
     * @example
     *     await client.workflowEndpoints.createWorkflow({
     *         name: "Invoice Processing"
     *     })
     */
    public createWorkflow(
        request: Extend.PostWorkflowsRequest,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): core.HttpResponsePromise<Extend.PostWorkflowsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createWorkflow(request, requestOptions));
    }

    private async __createWorkflow(
        request: Extend.PostWorkflowsRequest,
        requestOptions?: WorkflowEndpoints.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.PostWorkflowsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "workflows",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-extend-api-version":
                    (await core.Supplier.get(this._options.extendApiVersion)) != null
                        ? await core.Supplier.get(this._options.extendApiVersion)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "extendai",
                "X-Fern-SDK-Version": "0.0.11",
                "User-Agent": "extendai/0.0.11",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.PostWorkflowsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as Extend.Error_, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ExtendError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ExtendTimeoutError("Timeout exceeded when calling POST /workflows.");
            case "unknown":
                throw new errors.ExtendError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
