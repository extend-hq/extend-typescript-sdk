// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient";
import * as core from "../../../../core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers";
import * as environments from "../../../../environments";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError";
import * as errors from "../../../../errors/index";
import * as Extend from "../../../index";

export declare namespace ParseRunsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ParseRunsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ParseRunsClient.Options>;

    constructor(options: ParseRunsClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Parse files to get cleaned, chunked target content (e.g. markdown).
     *
     * The Parse endpoint allows you to convert documents into structured, machine-readable formats with fine-grained control over the parsing process. This endpoint is ideal for extracting cleaned document content to be used as context for downstream processing, e.g. RAG pipelines, custom ingestion pipelines, embeddings classification, etc.
     *
     * For more details, see the [Parse File guide](https://docs.extend.ai/2026-02-09/product/parsing/parse).
     *
     * @param {Extend.ParseRunsCreateRequest} request
     * @param {ParseRunsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.PaymentRequiredError}
     * @throws {@link Extend.ForbiddenError}
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.UnprocessableEntityError}
     * @throws {@link Extend.TooManyRequestsError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.parseRuns.create({
     *         file: {
     *             url: "url"
     *         }
     *     })
     */
    public create(
        request: Extend.ParseRunsCreateRequest,
        requestOptions?: ParseRunsClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.ParseRun> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Extend.ParseRunsCreateRequest,
        requestOptions?: ParseRunsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.ParseRun>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-extend-api-version": requestOptions?.extendApiVersion ?? "2026-02-09" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                "parse_runs",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 300) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.ParseRun, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Extend.PaymentRequiredError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Extend.ForbiddenError(_response.error.body as Extend.ApiError, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Extend.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/parse_runs");
    }

    /**
     * Retrieve the status and results of a parse run.
     *
     * Use this endpoint to get results for a parse run that has already completed, or to check on the status of a parse run initiated by the [Create Parse Run](https://docs.extend.ai/2026-02-09/developers/api-reference/endpoints/parse/create-parse-run) endpoint.
     *
     * @param {string} id - The unique identifier for the parse run.
     *
     *                      Example: `"pr_xK9mLPqRtN3vS8wF5hB2cQ"`
     * @param {Extend.ParseRunsRetrieveRequest} request
     * @param {ParseRunsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.PaymentRequiredError}
     * @throws {@link Extend.ForbiddenError}
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.UnprocessableEntityError}
     * @throws {@link Extend.TooManyRequestsError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.parseRuns.retrieve("parse_run_id_here")
     */
    public retrieve(
        id: string,
        request: Extend.ParseRunsRetrieveRequest = {},
        requestOptions?: ParseRunsClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.ParseRun> {
        return core.HttpResponsePromise.fromPromise(this.__retrieve(id, request, requestOptions));
    }

    private async __retrieve(
        id: string,
        request: Extend.ParseRunsRetrieveRequest = {},
        requestOptions?: ParseRunsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.ParseRun>> {
        const { responseType } = request;
        const _queryParams: Record<string, unknown> = {
            responseType: responseType != null ? responseType : undefined,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-extend-api-version": requestOptions?.extendApiVersion ?? "2026-02-09" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `parse_runs/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 300) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.ParseRun, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Extend.PaymentRequiredError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Extend.ForbiddenError(_response.error.body as Extend.ApiError, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Extend.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/parse_runs/{id}");
    }

    /**
     * Delete a parse run and all associated data from Extend. This operation is permanent and cannot be undone.
     *
     * This endpoint can be used if you'd like to manage data retention on your own rather than automated data retention policies. Or make one-off deletions for your downstream customers.
     *
     * @param {string} id - The ID of the parse run to delete.
     *
     *                      Example: `"pr_xK9mLPqRtN3vS8wF5hB2cQ"`
     * @param {ParseRunsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Extend.BadRequestError}
     * @throws {@link Extend.UnauthorizedError}
     * @throws {@link Extend.PaymentRequiredError}
     * @throws {@link Extend.ForbiddenError}
     * @throws {@link Extend.NotFoundError}
     * @throws {@link Extend.UnprocessableEntityError}
     * @throws {@link Extend.TooManyRequestsError}
     * @throws {@link Extend.InternalServerError}
     *
     * @example
     *     await client.parseRuns.delete("parse_run_id_here")
     */
    public delete(
        id: string,
        requestOptions?: ParseRunsClient.RequestOptions,
    ): core.HttpResponsePromise<Extend.ParseRunsDeleteResponse> {
        return core.HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
    }

    private async __delete(
        id: string,
        requestOptions?: ParseRunsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Extend.ParseRunsDeleteResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "x-extend-api-version": requestOptions?.extendApiVersion ?? "2026-02-09" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ExtendEnvironment.Production,
                `parse_runs/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 300) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Extend.ParseRunsDeleteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Extend.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Extend.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Extend.PaymentRequiredError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Extend.ForbiddenError(_response.error.body as Extend.ApiError, _response.rawResponse);
                case 404:
                    throw new Extend.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Extend.UnprocessableEntityError(
                        _response.error.body as Extend.ApiError,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Extend.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Extend.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ExtendError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/parse_runs/{id}");
    }
}
