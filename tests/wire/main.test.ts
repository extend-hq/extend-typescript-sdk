// This file was auto-generated by Fern from our API Definition.

import * as Extend from "../../src/api/index";
import { ExtendClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("ExtendClient", () => {
    test("parse (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = {
            object: "parse_run",
            id: "pr_xK9mLPqRtN3vS8wF5hB2cQ",
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: { id: "id", type: "Invoice", identifier: "other_2_9", startPage: 1, endPage: 10 },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            failureReason: "FILE_TYPE_NOT_SUPPORTED",
            failureMessage: "File type not supported for parsing.",
            output: {
                chunks: [
                    {
                        object: "chunk",
                        type: "page",
                        content: "This is the content of the chunk.",
                        metadata: { pageRange: { start: 1, end: 1 } },
                        blocks: [
                            {
                                object: "block",
                                id: "id",
                                type: "text",
                                content: "content",
                                details: { type: "table_details", rowCount: 1, columnCount: 1 },
                                metadata: {},
                                polygon: [{ x: 10, y: 20 }],
                                boundingBox: { left: 10, top: 10, right: 20, bottom: 20 },
                            },
                        ],
                    },
                ],
                ocr: {
                    words: [
                        {
                            content: "content",
                            boundingBox: { left: 10, top: 10, right: 20, bottom: 20 },
                            confidence: 1.1,
                            pageNumber: 1.1,
                        },
                    ],
                },
            },
            outputUrl: "https://...",
            metrics: { processingTimeMs: 1234, pageCount: 5 },
            config: {
                target: "markdown",
                chunkingStrategy: { type: "page", options: { minCharacters: 500, maxCharacters: 10000 } },
                engine: "parse_performance",
                advancedOptions: {
                    pageRotationEnabled: true,
                    pageRanges: [
                        { start: 1, end: 10 },
                        { start: 20, end: 30 },
                    ],
                    excelParsingMode: "basic",
                    excelSkipHiddenContent: true,
                    verticalGroupingThreshold: 1.1,
                },
            },
            usage: { credits: 10 },
        };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.parse({
            file: {
                url: "url",
            },
        });
        expect(response).toEqual({
            object: "parse_run",
            id: "pr_xK9mLPqRtN3vS8wF5hB2cQ",
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: {
                        id: "id",
                        type: "Invoice",
                        identifier: "other_2_9",
                        startPage: 1,
                        endPage: 10,
                    },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            failureReason: "FILE_TYPE_NOT_SUPPORTED",
            failureMessage: "File type not supported for parsing.",
            output: {
                chunks: [
                    {
                        object: "chunk",
                        type: "page",
                        content: "This is the content of the chunk.",
                        metadata: {
                            pageRange: {
                                start: 1,
                                end: 1,
                            },
                        },
                        blocks: [
                            {
                                object: "block",
                                id: "id",
                                type: "text",
                                content: "content",
                                details: {
                                    type: "table_details",
                                    rowCount: 1,
                                    columnCount: 1,
                                },
                                metadata: {},
                                polygon: [
                                    {
                                        x: 10,
                                        y: 20,
                                    },
                                ],
                                boundingBox: {
                                    left: 10,
                                    top: 10,
                                    right: 20,
                                    bottom: 20,
                                },
                            },
                        ],
                    },
                ],
                ocr: {
                    words: [
                        {
                            content: "content",
                            boundingBox: {
                                left: 10,
                                top: 10,
                                right: 20,
                                bottom: 20,
                            },
                            confidence: 1.1,
                            pageNumber: 1.1,
                        },
                    ],
                },
            },
            outputUrl: "https://...",
            metrics: {
                processingTimeMs: 1234,
                pageCount: 5,
            },
            config: {
                target: "markdown",
                chunkingStrategy: {
                    type: "page",
                    options: {
                        minCharacters: 500,
                        maxCharacters: 10000,
                    },
                },
                engine: "parse_performance",
                advancedOptions: {
                    pageRotationEnabled: true,
                    pageRanges: [
                        {
                            start: 1,
                            end: 10,
                        },
                        {
                            start: 20,
                            end: 30,
                        },
                    ],
                    excelParsingMode: "basic",
                    excelSkipHiddenContent: true,
                    verticalGroupingThreshold: 1.1,
                },
            },
            usage: {
                credits: 10,
            },
        });
    });

    test("parse (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.parse({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.BadRequestError);
    });

    test("parse (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.parse({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnauthorizedError);
    });

    test("parse (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(402)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.parse({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.PaymentRequiredError);
    });

    test("parse (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.parse({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.ForbiddenError);
    });

    test("parse (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.parse({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.NotFoundError);
    });

    test("parse (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.parse({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnprocessableEntityError);
    });

    test("parse (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.parse({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.TooManyRequestsError);
    });

    test("parse (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/parse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.parse({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.InternalServerError);
    });

    test("edit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = {
            object: "edit_run",
            id: "edr_xK9mLPqRtN3vS8wF5hB2cQ",
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: { id: "id", type: "Invoice", identifier: "other_2_9", startPage: 1, endPage: 10 },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            failureReason: "FILE_TYPE_NOT_SUPPORTED",
            failureMessage: "File type not supported. Edit runs currently require a PDF.",
            config: {
                schema: { type: "object", properties: { key: {} }, required: ["required"], additionalProperties: true },
                instructions: "instructions",
                advancedOptions: { tableParsingEnabled: true, flattenPdf: true },
            },
            output: {
                editedFile: {
                    id: "file_Ab3cDE45Fg6hIj7KlM8nO",
                    presignedUrl: "https://extend-ai-files.s3.amazonaws.com/...",
                },
                filledValues: { key: "value" },
            },
            metrics: {
                processingTimeMs: 1234,
                pageCount: 5,
                fieldCount: 10,
                fieldsDetectedCount: 8,
                fieldsAnnotatedCount: 10,
                fieldDetectionTimeMs: 500,
                fieldAnnotationTimeMs: 200,
                fieldFillingTimeMs: 300,
            },
            usage: { credits: 10 },
        };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.edit({
            file: {
                url: "url",
            },
        });
        expect(response).toEqual({
            object: "edit_run",
            id: "edr_xK9mLPqRtN3vS8wF5hB2cQ",
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: {
                        id: "id",
                        type: "Invoice",
                        identifier: "other_2_9",
                        startPage: 1,
                        endPage: 10,
                    },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            failureReason: "FILE_TYPE_NOT_SUPPORTED",
            failureMessage: "File type not supported. Edit runs currently require a PDF.",
            config: {
                schema: {
                    type: "object",
                    properties: {
                        key: {},
                    },
                    required: ["required"],
                    additionalProperties: true,
                },
                instructions: "instructions",
                advancedOptions: {
                    tableParsingEnabled: true,
                    flattenPdf: true,
                },
            },
            output: {
                editedFile: {
                    id: "file_Ab3cDE45Fg6hIj7KlM8nO",
                    presignedUrl: "https://extend-ai-files.s3.amazonaws.com/...",
                },
                filledValues: {
                    key: "value",
                },
            },
            metrics: {
                processingTimeMs: 1234,
                pageCount: 5,
                fieldCount: 10,
                fieldsDetectedCount: 8,
                fieldsAnnotatedCount: 10,
                fieldDetectionTimeMs: 500,
                fieldAnnotationTimeMs: 200,
                fieldFillingTimeMs: 300,
            },
            usage: {
                credits: 10,
            },
        });
    });

    test("edit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.edit({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.BadRequestError);
    });

    test("edit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.edit({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnauthorizedError);
    });

    test("edit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(402)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.edit({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.PaymentRequiredError);
    });

    test("edit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.edit({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.ForbiddenError);
    });

    test("edit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.edit({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.NotFoundError);
    });

    test("edit (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.edit({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnprocessableEntityError);
    });

    test("edit (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.edit({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.TooManyRequestsError);
    });

    test("edit (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/edit")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.edit({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.InternalServerError);
    });

    test("extract (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = {
            object: "extract_run",
            id: "exr_Xj8mK2pL9nR4vT7qY5wZ",
            extractor: {
                object: "extractor",
                id: "ex_Xj8mK2pL9nR4vT7qY5wZ",
                name: "Invoice Extractor",
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            extractorVersion: {
                object: "extractor_version",
                id: "exv_xK9mLPqRtN3vS8wF5hB2cQ",
                description: "Updated extraction fields for new invoice format",
                version: "draft",
                extractorId: "ex_Xj8mK2pL9nR4vT7qY5wZ",
                createdAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            output: { value: { key: "value" }, metadata: { key: { logprobsConfidence: null } } },
            initialOutput: { value: { key: "value" }, metadata: { key: { logprobsConfidence: null } } },
            reviewedOutput: { value: { key: "value" }, metadata: { key: { logprobsConfidence: null } } },
            failureReason: "PARSING_ERROR",
            failureMessage: "failureMessage",
            metadata: { key: "value" },
            reviewed: false,
            edited: false,
            edits: {
                key: {
                    originalValue: { key: "value" },
                    editedValue: { key: "value" },
                    notes: "This is a note about the edit.",
                    page: 15,
                    fieldType: "string",
                },
            },
            config: {
                baseProcessor: "extraction_performance",
                baseVersion: "baseVersion",
                extractionRules: "extractionRules",
                schema: { key: "value" },
                advancedOptions: {
                    modelReasoningInsightsEnabled: true,
                    advancedMultimodalEnabled: true,
                    citationsEnabled: true,
                    arrayCitationStrategy: "item",
                    arrayStrategy: { type: "large_array_heuristics" },
                    excelSheetRanges: [{ start: 1, end: 1 }],
                    excelSheetSelectionStrategy: "intelligent",
                    pageRanges: [
                        { start: 1, end: 10 },
                        { start: 20, end: 30 },
                    ],
                },
                parseConfig: {
                    target: "markdown",
                    engine: "parse_performance",
                    advancedOptions: {
                        pageRanges: [
                            { start: 1, end: 10 },
                            { start: 20, end: 30 },
                        ],
                    },
                },
            },
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: { id: "id", type: "Invoice", identifier: "other_2_9", startPage: 1, endPage: 10 },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            parseRunId: "pr_Xj8mK2pL9nR4vT7qY5wZ",
            dashboardUrl: "https://dashboard.extend.ai/runs/exr_Xj8mK2pL9nR4vT7qY5wZ",
            usage: { credits: 10 },
            createdAt: "2024-03-21T16:45:00Z",
            updatedAt: "2024-03-21T16:45:00Z",
        };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.extract({
            file: {
                url: "url",
            },
        });
        expect(response).toEqual({
            object: "extract_run",
            id: "exr_Xj8mK2pL9nR4vT7qY5wZ",
            extractor: {
                object: "extractor",
                id: "ex_Xj8mK2pL9nR4vT7qY5wZ",
                name: "Invoice Extractor",
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            extractorVersion: {
                object: "extractor_version",
                id: "exv_xK9mLPqRtN3vS8wF5hB2cQ",
                description: "Updated extraction fields for new invoice format",
                version: "draft",
                extractorId: "ex_Xj8mK2pL9nR4vT7qY5wZ",
                createdAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            output: {
                value: {
                    key: "value",
                },
                metadata: {
                    key: {
                        logprobsConfidence: null,
                    },
                },
            },
            initialOutput: {
                value: {
                    key: "value",
                },
                metadata: {
                    key: {
                        logprobsConfidence: null,
                    },
                },
            },
            reviewedOutput: {
                value: {
                    key: "value",
                },
                metadata: {
                    key: {
                        logprobsConfidence: null,
                    },
                },
            },
            failureReason: "PARSING_ERROR",
            failureMessage: "failureMessage",
            metadata: {
                key: "value",
            },
            reviewed: false,
            edited: false,
            edits: {
                key: {
                    originalValue: {
                        key: "value",
                    },
                    editedValue: {
                        key: "value",
                    },
                    notes: "This is a note about the edit.",
                    page: 15,
                    fieldType: "string",
                },
            },
            config: {
                baseProcessor: "extraction_performance",
                baseVersion: "baseVersion",
                extractionRules: "extractionRules",
                schema: {
                    key: "value",
                },
                advancedOptions: {
                    modelReasoningInsightsEnabled: true,
                    advancedMultimodalEnabled: true,
                    citationsEnabled: true,
                    arrayCitationStrategy: "item",
                    arrayStrategy: {
                        type: "large_array_heuristics",
                    },
                    excelSheetRanges: [
                        {
                            start: 1,
                            end: 1,
                        },
                    ],
                    excelSheetSelectionStrategy: "intelligent",
                    pageRanges: [
                        {
                            start: 1,
                            end: 10,
                        },
                        {
                            start: 20,
                            end: 30,
                        },
                    ],
                },
                parseConfig: {
                    target: "markdown",
                    engine: "parse_performance",
                    advancedOptions: {
                        pageRanges: [
                            {
                                start: 1,
                                end: 10,
                            },
                            {
                                start: 20,
                                end: 30,
                            },
                        ],
                    },
                },
            },
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: {
                        id: "id",
                        type: "Invoice",
                        identifier: "other_2_9",
                        startPage: 1,
                        endPage: 10,
                    },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            parseRunId: "pr_Xj8mK2pL9nR4vT7qY5wZ",
            dashboardUrl: "https://dashboard.extend.ai/runs/exr_Xj8mK2pL9nR4vT7qY5wZ",
            usage: {
                credits: 10,
            },
            createdAt: "2024-03-21T16:45:00Z",
            updatedAt: "2024-03-21T16:45:00Z",
        });
    });

    test("extract (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.extract({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.BadRequestError);
    });

    test("extract (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.extract({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnauthorizedError);
    });

    test("extract (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(402)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.extract({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.PaymentRequiredError);
    });

    test("extract (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.extract({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.ForbiddenError);
    });

    test("extract (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.extract({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.NotFoundError);
    });

    test("extract (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.extract({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnprocessableEntityError);
    });

    test("extract (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.extract({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.TooManyRequestsError);
    });

    test("extract (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.extract({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.InternalServerError);
    });

    test("classify (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = {
            object: "classify_run",
            id: "clr_Xj8mK2pL9nR4vT7qY5wZ",
            classifier: {
                object: "classifier",
                id: "cl_Xj8mK2pL9nR4vT7qY5wZ",
                name: "Document Type Classifier",
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            classifierVersion: {
                object: "classifier_version",
                id: "clv_xK9mLPqRtN3vS8wF5hB2cQ",
                description: "Added new document types for Q4 processing",
                version: "draft",
                classifierId: "cl_Xj8mK2pL9nR4vT7qY5wZ",
                createdAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            output: { id: "id", type: "type", confidence: 1.1, insights: [{ type: "reasoning", content: "content" }] },
            initialOutput: {
                id: "id",
                type: "type",
                confidence: 1.1,
                insights: [{ type: "reasoning", content: "content" }],
            },
            reviewedOutput: {
                id: "id",
                type: "type",
                confidence: 1.1,
                insights: [{ type: "reasoning", content: "content" }],
            },
            failureReason: "PARSING_ERROR",
            failureMessage: "failureMessage",
            metadata: { key: "value" },
            reviewed: false,
            edited: false,
            config: {
                baseProcessor: "classification_performance",
                baseVersion: "3.2.0",
                classifications: [
                    {
                        id: "my_unique_id",
                        type: "invoice",
                        description:
                            "An invoice is a document that lists the items purchased and the total amount due.",
                    },
                ],
                classificationRules:
                    "Remember, when it comes to differentiating between invoices and purchase orders, the most important thing to look for is the date of the document.",
                advancedOptions: {
                    context: "default",
                    advancedMultimodalEnabled: true,
                    pageRanges: [
                        { start: 1, end: 10 },
                        { start: 20, end: 30 },
                    ],
                },
                parseConfig: {
                    target: "markdown",
                    engine: "parse_performance",
                    advancedOptions: {
                        pageRanges: [
                            { start: 1, end: 10 },
                            { start: 20, end: 30 },
                        ],
                    },
                },
            },
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: { id: "id", type: "Invoice", identifier: "other_2_9", startPage: 1, endPage: 10 },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            parseRunId: "pr_Xj8mK2pL9nR4vT7qY5wZ",
            dashboardUrl: "https://dashboard.extend.ai/runs/clr_Xj8mK2pL9nR4vT7qY5wZ",
            usage: { credits: 10 },
            createdAt: "2024-03-21T16:45:00Z",
            updatedAt: "2024-03-21T16:45:00Z",
        };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.classify({
            file: {
                url: "url",
            },
        });
        expect(response).toEqual({
            object: "classify_run",
            id: "clr_Xj8mK2pL9nR4vT7qY5wZ",
            classifier: {
                object: "classifier",
                id: "cl_Xj8mK2pL9nR4vT7qY5wZ",
                name: "Document Type Classifier",
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            classifierVersion: {
                object: "classifier_version",
                id: "clv_xK9mLPqRtN3vS8wF5hB2cQ",
                description: "Added new document types for Q4 processing",
                version: "draft",
                classifierId: "cl_Xj8mK2pL9nR4vT7qY5wZ",
                createdAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            output: {
                id: "id",
                type: "type",
                confidence: 1.1,
                insights: [
                    {
                        type: "reasoning",
                        content: "content",
                    },
                ],
            },
            initialOutput: {
                id: "id",
                type: "type",
                confidence: 1.1,
                insights: [
                    {
                        type: "reasoning",
                        content: "content",
                    },
                ],
            },
            reviewedOutput: {
                id: "id",
                type: "type",
                confidence: 1.1,
                insights: [
                    {
                        type: "reasoning",
                        content: "content",
                    },
                ],
            },
            failureReason: "PARSING_ERROR",
            failureMessage: "failureMessage",
            metadata: {
                key: "value",
            },
            reviewed: false,
            edited: false,
            config: {
                baseProcessor: "classification_performance",
                baseVersion: "3.2.0",
                classifications: [
                    {
                        id: "my_unique_id",
                        type: "invoice",
                        description:
                            "An invoice is a document that lists the items purchased and the total amount due.",
                    },
                ],
                classificationRules:
                    "Remember, when it comes to differentiating between invoices and purchase orders, the most important thing to look for is the date of the document.",
                advancedOptions: {
                    context: "default",
                    advancedMultimodalEnabled: true,
                    pageRanges: [
                        {
                            start: 1,
                            end: 10,
                        },
                        {
                            start: 20,
                            end: 30,
                        },
                    ],
                },
                parseConfig: {
                    target: "markdown",
                    engine: "parse_performance",
                    advancedOptions: {
                        pageRanges: [
                            {
                                start: 1,
                                end: 10,
                            },
                            {
                                start: 20,
                                end: 30,
                            },
                        ],
                    },
                },
            },
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: {
                        id: "id",
                        type: "Invoice",
                        identifier: "other_2_9",
                        startPage: 1,
                        endPage: 10,
                    },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            parseRunId: "pr_Xj8mK2pL9nR4vT7qY5wZ",
            dashboardUrl: "https://dashboard.extend.ai/runs/clr_Xj8mK2pL9nR4vT7qY5wZ",
            usage: {
                credits: 10,
            },
            createdAt: "2024-03-21T16:45:00Z",
            updatedAt: "2024-03-21T16:45:00Z",
        });
    });

    test("classify (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.classify({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.BadRequestError);
    });

    test("classify (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.classify({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnauthorizedError);
    });

    test("classify (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(402)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.classify({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.PaymentRequiredError);
    });

    test("classify (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.classify({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.ForbiddenError);
    });

    test("classify (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.classify({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.NotFoundError);
    });

    test("classify (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.classify({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnprocessableEntityError);
    });

    test("classify (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.classify({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.TooManyRequestsError);
    });

    test("classify (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/classify")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.classify({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.InternalServerError);
    });

    test("split (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = {
            object: "split_run",
            id: "splr_Xj8mK2pL9nR4vT7qY5wZ",
            splitter: {
                object: "splitter",
                id: "spl_Xj8mK2pL9nR4vT7qY5wZ",
                name: "Invoice Packet Splitter",
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            splitterVersion: {
                object: "splitter_version",
                id: "splv_xK9mLPqRtN3vS8wF5hB2cQ",
                description: "Updated split rules for multi-invoice packets",
                version: "draft",
                splitterId: "spl_Xj8mK2pL9nR4vT7qY5wZ",
                createdAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            output: {
                splits: [
                    {
                        type: "type",
                        observation: "observation",
                        identifier: "identifier",
                        startPage: 1,
                        endPage: 1,
                        classificationId: "classificationId",
                        id: "id",
                        fileId: "fileId",
                    },
                ],
                isExternal: true,
            },
            initialOutput: {
                splits: [
                    {
                        type: "type",
                        observation: "observation",
                        identifier: "identifier",
                        startPage: 1,
                        endPage: 1,
                        classificationId: "classificationId",
                        id: "id",
                        fileId: "fileId",
                    },
                ],
                isExternal: true,
            },
            reviewedOutput: {
                splits: [
                    {
                        type: "type",
                        observation: "observation",
                        identifier: "identifier",
                        startPage: 1,
                        endPage: 1,
                        classificationId: "classificationId",
                        id: "id",
                        fileId: "fileId",
                    },
                ],
                isExternal: true,
            },
            failureReason: "PARSING_ERROR",
            failureMessage: "failureMessage",
            metadata: { key: "value" },
            reviewed: false,
            edited: false,
            config: {
                baseProcessor: "splitting_performance",
                baseVersion: "baseVersion",
                splitClassifications: [
                    {
                        id: "my_unique_id",
                        type: "invoice",
                        description:
                            "An invoice is a document that lists the items purchased and the total amount due.",
                    },
                ],
                splitRules: "splitRules",
                advancedOptions: {
                    splitIdentifierRules: "splitIdentifierRules",
                    splitMethod: "high_precision",
                    splitExcelDocumentsBySheetEnabled: true,
                    pageRanges: [
                        { start: 1, end: 10 },
                        { start: 20, end: 30 },
                    ],
                    pageOverlapEnabled: true,
                },
                parseConfig: {
                    target: "markdown",
                    engine: "parse_performance",
                    advancedOptions: {
                        pageRanges: [
                            { start: 1, end: 10 },
                            { start: 20, end: 30 },
                        ],
                    },
                },
            },
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: { id: "id", type: "Invoice", identifier: "other_2_9", startPage: 1, endPage: 10 },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            parseRunId: "pr_Xj8mK2pL9nR4vT7qY5wZ",
            dashboardUrl: "https://dashboard.extend.ai/runs/splr_Xj8mK2pL9nR4vT7qY5wZ",
            usage: { credits: 10 },
            createdAt: "2024-03-21T16:45:00Z",
            updatedAt: "2024-03-21T16:45:00Z",
        };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.split({
            file: {
                url: "url",
            },
        });
        expect(response).toEqual({
            object: "split_run",
            id: "splr_Xj8mK2pL9nR4vT7qY5wZ",
            splitter: {
                object: "splitter",
                id: "spl_Xj8mK2pL9nR4vT7qY5wZ",
                name: "Invoice Packet Splitter",
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            splitterVersion: {
                object: "splitter_version",
                id: "splv_xK9mLPqRtN3vS8wF5hB2cQ",
                description: "Updated split rules for multi-invoice packets",
                version: "draft",
                splitterId: "spl_Xj8mK2pL9nR4vT7qY5wZ",
                createdAt: "2024-03-21T16:45:00Z",
            },
            status: "PROCESSING",
            output: {
                splits: [
                    {
                        type: "type",
                        observation: "observation",
                        identifier: "identifier",
                        startPage: 1,
                        endPage: 1,
                        classificationId: "classificationId",
                        id: "id",
                        fileId: "fileId",
                    },
                ],
                isExternal: true,
            },
            initialOutput: {
                splits: [
                    {
                        type: "type",
                        observation: "observation",
                        identifier: "identifier",
                        startPage: 1,
                        endPage: 1,
                        classificationId: "classificationId",
                        id: "id",
                        fileId: "fileId",
                    },
                ],
                isExternal: true,
            },
            reviewedOutput: {
                splits: [
                    {
                        type: "type",
                        observation: "observation",
                        identifier: "identifier",
                        startPage: 1,
                        endPage: 1,
                        classificationId: "classificationId",
                        id: "id",
                        fileId: "fileId",
                    },
                ],
                isExternal: true,
            },
            failureReason: "PARSING_ERROR",
            failureMessage: "failureMessage",
            metadata: {
                key: "value",
            },
            reviewed: false,
            edited: false,
            config: {
                baseProcessor: "splitting_performance",
                baseVersion: "baseVersion",
                splitClassifications: [
                    {
                        id: "my_unique_id",
                        type: "invoice",
                        description:
                            "An invoice is a document that lists the items purchased and the total amount due.",
                    },
                ],
                splitRules: "splitRules",
                advancedOptions: {
                    splitIdentifierRules: "splitIdentifierRules",
                    splitMethod: "high_precision",
                    splitExcelDocumentsBySheetEnabled: true,
                    pageRanges: [
                        {
                            start: 1,
                            end: 10,
                        },
                        {
                            start: 20,
                            end: 30,
                        },
                    ],
                    pageOverlapEnabled: true,
                },
                parseConfig: {
                    target: "markdown",
                    engine: "parse_performance",
                    advancedOptions: {
                        pageRanges: [
                            {
                                start: 1,
                                end: 10,
                            },
                            {
                                start: 20,
                                end: 30,
                            },
                        ],
                    },
                },
            },
            file: {
                object: "file",
                id: "file_xK9mLPqRtN3vS8wF5hB2cQ",
                name: "Invoices.pdf",
                type: "PDF",
                parentFileId: "file_Zk9mNP12Qw4yTv8BdR3H",
                metadata: {
                    pageCount: 30,
                    parentSplit: {
                        id: "id",
                        type: "Invoice",
                        identifier: "other_2_9",
                        startPage: 1,
                        endPage: 10,
                    },
                },
                createdAt: "2024-03-21T16:45:00Z",
                updatedAt: "2024-03-21T16:45:00Z",
            },
            parseRunId: "pr_Xj8mK2pL9nR4vT7qY5wZ",
            dashboardUrl: "https://dashboard.extend.ai/runs/splr_Xj8mK2pL9nR4vT7qY5wZ",
            usage: {
                credits: 10,
            },
            createdAt: "2024-03-21T16:45:00Z",
            updatedAt: "2024-03-21T16:45:00Z",
        });
    });

    test("split (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.split({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.BadRequestError);
    });

    test("split (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.split({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnauthorizedError);
    });

    test("split (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(402)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.split({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.PaymentRequiredError);
    });

    test("split (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.split({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.ForbiddenError);
    });

    test("split (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.split({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.NotFoundError);
    });

    test("split (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { code: "code", message: "message", retryable: true };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.split({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.UnprocessableEntityError);
    });

    test("split (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.split({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.TooManyRequestsError);
    });

    test("split (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new ExtendClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { file: { url: "url" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/split")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.split({
                file: {
                    url: "url",
                },
            });
        }).rejects.toThrow(Extend.InternalServerError);
    });
});
